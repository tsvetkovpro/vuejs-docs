<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>vue js</title>
</head>
<body>



<!-- /*На помощь приходят вычисляемые свойства.
	Простой пример*/ -->

	<div id="example">
		<p>Изначальное сообщение: "{{ message }}"</p>
		<p>Сообщение задом наперёд: "{{ reversedMessage }}"</p>
	</div>



<!-- Кеширование вычисляемых свойств

Вы могли заметить, что тот же результат можно достигнуть при помощи метода:
<p>Сообщение задом наперёд: "{{ reverseMessage() }}"</p>
// в компоненте
methods: {
  reverseMessage: function () {
    return this.message.split('').reverse().join('')
  }

Вместо вычисляемого свойства, мы можем указать ту же самую
функцию в качестве метода. С точки зрения конечного результата,
оба подхода действительно делают одно и то же. Но есть важное
различие: вычисляемые свойства кэшируются, основываясь на своих
зависимостях. Вычисляемое свойство будет пересчитано только тогда,
когда изменится одна из его зависимостей. Поэтому, пока message
остаётся неизменным, многократное обращение к reversedMessage
будет каждый раз незамедлительно возвращать единожды вычисленное
значение, не запуская функцию вновь.

} -->



<!-- Вычисляемые свойства и слежение -->
<!-- Vue также предоставляет и более общий способ наблюдения и реагирования на изменения данных в инстансе: слежение за свойствами. -->
<div id="demo">{{ fullName }}</div>



<!-- По умолчанию вычисляемые свойства работают только на чтение, но в случае необходимости вы можете также указать и сеттер: -->
<div id="demo1">{{ fullName }}</div>









<script src="https://unpkg.com/vue/dist/vue.js"></script>
<script src="main.js"></script>









</body>
</html>